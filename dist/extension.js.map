{
  "version": 3,
  "sources": ["../src/extension.ts", "../src/stubGenerator.ts"],
  "sourcesContent": ["\nimport * as vscode from 'vscode';\nimport { generateStub, findStubComments, insertStub } from './stubGenerator';\n\n/**\n * @rhizome: how do libraries work here?\n *\n * In VSCode extensions, local TypeScript files are bundled with the extension.\n * We import from ./stubGenerator (same directory, same bundle).\n * esbuild will tree-shake unused code and bundle everything into dist/extension.js.\n *\n * Path aliases (@rhizome/lib) come later if we extract to separate package.\n * For now: relative imports within src/ work fine.\n */\n\n/**\n * Activate extension on startup\n *\n * don-socratic asks:\n * What's the user's workflow? They write a comment, then what?\n * Do they:\n * a) Right-click on the red squiggle?\n * b) Hit a keyboard shortcut?\n * c) Something else?\n *\n * How do they KNOW the extension is listening?\n * What feedback do they get?\n *\n * ANSWER (from UX & workflow design):\n * Workflow A: Select code \u2192 right-click \u2192 \"Ask don-socratic\" (context menu)\n *   - User sees it in menu (feedback = visibility)\n *   - Package.json already has menu entry for donSocratic command\n *   - Shows when editor has selection (when condition)\n *   - Response appears in webview or output channel\n *\n * Workflow B (future): @rhizome stub comment above function \u2192 right-click \u2192 \"Stub this function\"\n *   - User sees function signature \u2192 underline \u2192 context action\n *   - Or: keyboard shortcut (configure in keybindings)\n *   - Stub appears in file after triggering\n *\n * For now: Build workflow A fully. Stub command can follow same pattern.\n * Feedback: Use vscode.window.showInformationMessage() for simple cases,\n * webview panel for rich responses (show personas, chat history, etc.)\n */\nexport function activate(context: vscode.ExtensionContext) {\n\tconsole.log('vscode-rhizome activated');\n\n\t// ======================================\n\t// CORE FEATURE: don-socratic guidance\n\t// ======================================\n\t// The don is always listening. When you select code, he brings\n\t// Socratic questioning to bear on what you're building.\n\t//\n\t// Workflow: Select code \u2192 right-click \u2192 \"Ask don-socratic\"\n\t// Response: Shows in output channel (for now; webview later)\n\t//\n\t// CURRENT IMPLEMENTATION:\n\t// 1. Get active editor and selection (user feedback: \"What are you seeing?\" )\n\t// 2. Create or show output channel\n\t// 3. Log what we're about to do (for MVP: just show the code)\n\t// 4. TODO: Call rhizome CLI with persona + code \u2192 get LLM response\n\t// 5. Display response to user\n\t//\n\tlet donSocraticDisposable = vscode.commands.registerCommand('vscode-rhizome.donSocratic', async () => {\n\t\tconst editor = vscode.window.activeTextEditor;\n\t\tif (!editor) {\n\t\t\tvscode.window.showErrorMessage('No active editor');\n\t\t\treturn;\n\t\t}\n\n\t\tconst selection = editor.selection;\n\t\tconst selectedText = editor.document.getText(selection);\n\n\t\tif (!selectedText) {\n\t\t\tvscode.window.showErrorMessage('Please select code to question');\n\t\t\treturn;\n\t\t}\n\n\t\t// Show user we're doing something\n\t\tawait vscode.window.showInformationMessage('Asking don-socratic...');\n\n\t\t// Create or get output channel for responses\n\t\tconst outputChannel = vscode.window.createOutputChannel('vscode-rhizome');\n\t\toutputChannel.show(true);\n\n\t\t// Log what we're about to do\n\t\toutputChannel.appendLine('='.repeat(60));\n\t\toutputChannel.appendLine('don-socratic');\n\t\toutputChannel.appendLine('='.repeat(60));\n\t\toutputChannel.appendLine('Selected code:');\n\t\toutputChannel.appendLine('');\n\t\toutputChannel.appendLine(selectedText);\n\t\toutputChannel.appendLine('');\n\t\toutputChannel.appendLine('--- Waiting for persona response ---');\n\t\toutputChannel.appendLine('');\n\n\t\t// TODO: Call rhizome CLI: rhizome ask --persona don-socratic <selected code>\n\t\t// TODO: Parse JSON response\n\t\t// TODO: Display in output channel\n\t\t// For now, placeholder:\n\t\toutputChannel.appendLine('(Persona-LLM integration coming soon)');\n\t});\n\n\tcontext.subscriptions.push(donSocraticDisposable);\n\n\t// ======================================\n\t// STUB GENERATION\n\t// ======================================\n\t// don-socratic asks:\n\t// When someone invokes the stub command, what needs to happen?\n\t// 1. Find the @rhizome stub comment?\n\t// 2. Parse the function signature?\n\t// 3. Generate the stub?\n\t// 4. Insert it into the file?\n\t//\n\t// In what order? And how do you know each step succeeded?\n\t//\n\t// ANSWER (step-by-step workflow):\n\t// 1. Get active editor (vscode.window.activeTextEditor)\n\t// 2. Get the document text (editor.document.getText())\n\t// 3. Find all @rhizome stub comments (findStubComments from stubGenerator)\n\t// 4. If multiple, ask user which one (InputBox)\n\t// 5. For selected stub:\n\t//    a. Extract function signature\n\t//    b. Detect language from file extension\n\t//    c. Call generateStub(functionName, params, returnType, language)\n\t//    d. Call insertStub(code, line, generatedStub, language)\n\t// 6. Apply edit to document (TextEdit)\n\t// 7. Show success/error message\n\t//\n\t// Error handling: Show user what went wrong at each step\n\t//\n\tlet stubDisposable = vscode.commands.registerCommand('vscode-rhizome.stub', async () => {\n\t\tconst editor = vscode.window.activeTextEditor;\n\t\tif (!editor) {\n\t\t\tvscode.window.showErrorMessage('No active editor');\n\t\t\treturn;\n\t\t}\n\n\t\tconst document = editor.document;\n\t\tconst code = document.getText();\n\n\t\t// Detect language from file extension\n\t\tconst ext = document.languageId; // 'typescript', 'javascript', 'python', etc.\n\t\tconst language = ext === 'typescript' || ext === 'javascript' ? 'typescript' : ext === 'python' ? 'python' : null;\n\n\t\tif (!language) {\n\t\t\tvscode.window.showErrorMessage(`Unsupported language: ${ext}. Use TypeScript, JavaScript, or Python.`);\n\t\t\treturn;\n\t\t}\n\n\t\t// Find @rhizome stub comments in the file\n\t\tconst stubs = findStubComments(code, language);\n\n\t\tif (stubs.length === 0) {\n\t\t\tvscode.window.showWarningMessage('No @rhizome stub comments found in this file');\n\t\t\treturn;\n\t\t}\n\n\t\t// If multiple stubs, ask user which one\n\t\tlet targetStub = stubs[0];\n\t\tif (stubs.length > 1) {\n\t\t\tconst picked = await vscode.window.showQuickPick(\n\t\t\t\tstubs.map((s) => `Line ${s.line}: ${s.functionName}`),\n\t\t\t\t{ placeHolder: 'Which function to stub?' }\n\t\t\t);\n\t\t\tif (!picked) return;\n\t\t\tconst index = stubs.map((s) => `Line ${s.line}: ${s.functionName}`).indexOf(picked);\n\t\t\ttargetStub = stubs[index];\n\t\t}\n\n\t\t// Generate stub code\n\t\tconst stub = generateStub(targetStub.functionName, targetStub.params, targetStub.returnType, language as any);\n\n\t\t// Insert stub into file\n\t\tconst modifiedCode = insertStub(code, targetStub.line, stub, language);\n\n\t\t// Apply edit to document\n\t\tconst fullRange = new vscode.Range(document.positionAt(0), document.positionAt(code.length));\n\t\tconst edit = new vscode.TextEdit(fullRange, modifiedCode);\n\n\t\t// Create workspace edit and apply\n\t\tconst workspaceEdit = new vscode.WorkspaceEdit();\n\t\tworkspaceEdit.set(document.uri, [edit]);\n\t\tawait vscode.workspace.applyEdit(workspaceEdit);\n\n\t\tvscode.window.showInformationMessage(`Stub created for ${targetStub.functionName}`);\n\t});\n\n\tcontext.subscriptions.push(stubDisposable);\n}\n\nexport function deactivate() {}\n\n", "/**\n * Stub Generator\n *\n * don-socratic asks:\n * Before you write a line, answer this: what does \"stub\" actually MEAN?\n * When a developer sees the generated stub, what must be there?\n * What must NOT be there?\n *\n * Think carefully. Write down your answer in the comment below before proceeding.\n *\n * ANSWER (from dev-guide + code-reviewer collaboration):\n * A stub for vscode-rhizome is:\n *\n * MUST HAVE:\n * \u2713 Function signature with available type information\n * \u2713 throw new Error('Not implemented') | raise NotImplementedError()\n * \u2713 TODO comment that mentions the function name\n * \u2713 Optional: ISO 8601 timestamp, user story reference (e.g., \"US-123: As a user...\")\n * \u2713 Language-specific syntax (TS throws Error, Python raises NotImplementedError)\n *\n * MUST NOT HAVE:\n * \u2717 Partial implementation or misleading logic\n * \u2717 Vague TODO (must include function name for context outside editor)\n * \u2717 Assumption about parameter types (infer from signature or mark as unknown)\n *\n * RATIONALE:\n * - Prevents linter errors (undefined function \u2192 defined, throws as expected)\n * - Forces explicit intent (TODO + timestamp = \"I thought about this\")\n * - Supports TODO backlog tracking (searchable by function name)\n * - Integrates with user story workflow (reference in comment)\n * - Language-consistent (developers recognize pattern across TS/JS/Python)\n */\n\n/**\n * Parse a function signature and generate a stub\n *\n * don-socratic asks:\n * What languages are we dealing with? (TS, JS, Python)\n * How do we know where to insert the stub?\n * What's the minimal stub that satisfies your definition above?\n *\n * TODO: Implement stub generation\n * TODO: What's the function signature?\n * TODO: What's the return type?\n * TODO: What error do we throw?\n * TODO: What TODO comment do we add?\n */\nexport function generateStub(\n\tfunctionName: string,\n\tparams: string,           // e.g., \"(x: number, y?: string)\" \u2014 keep as-is from signature\n\treturnType: string | null, // e.g., \"string\" or \"Promise<void>\" or null if untyped\n\tlanguage: 'typescript' | 'javascript' | 'python',\n\toptions?: {\n\t\ttimestamp?: string;   // ISO 8601: \"2025-10-23T21:00:00Z\" (optional)\n\t\tuserStory?: string;   // e.g., \"US-142: As a developer...\"  (optional)\n\t}\n): string {\n\tthrow new Error('Not implemented');\n\n\t// LANGUAGE-SPECIFIC SYNTAX & API HOOKS:\n\t//\n\t// TypeScript/JavaScript:\n\t//   - throw new Error('message')\n\t//   - Async functions: same syntax\n\t//   - Arrow functions: same syntax\n\t//   - Example: function getName(x: number): string { throw new Error(...) }\n\t//\n\t// Python:\n\t//   - raise NotImplementedError()\n\t//   - Async functions: async def (same raise syntax)\n\t//   - Example: def get_name(x: int) -> str:\n\t//                   raise NotImplementedError()\n\t//\n\t// TYPED VS UNTYPED HANDLING:\n\t//   - If returnType is provided: use it (generateStub is called with extracted types)\n\t//   - If returnType is null: don't infer. Leave blank or mark as 'unknown' in TS\n\t//   - If params have types: keep them. If not, keep the bare param names\n\t//   - Don't guess parameter types at stub-generation time. Type inference is LLM's job (future).\n\t//\n\t// TODO COMMENT FORMAT:\n\t//   - MUST include function name (seen outside code context in TODO backlog)\n\t//   - SHOULD include timestamp (when was this stubbed?)\n\t//   - MAY include user story reference (why does this function exist?)\n\t//   - Example: \"TODO: Implement getName (stubbed 2025-10-23T21:00:00Z, US-142)\"\n\t//\n\t// STUB BODY:\n\t//   - Single throw/raise statement (not a comment, actual executable code)\n\t//   - Message includes function name for debugging: throw new Error('Not implemented: getName')\n\t//   - Python: raise NotImplementedError('get_name')\n}\n\n\n\n/**\n * Find @rhizome stub comments in code\n *\n * don-socratic observes:\n * You know regex. So why not start there? Split the code into lines,\n * find the ones with @rhizome stub. You've got line numbers. Easy.\n *\n * Then\u2014and here's where it gets interesting\u2014you need to know what comes next.\n * A function signature. But it looks *different* in each language.\n * Have you thought about what MUST be true about that signature?\n * (Is it always on the very next line? Or could there be whitespace?)\n *\n * For the actual parsing: languages have tools. TypeScript has @babel/parser.\n * Python has ast (built-in!). But you might not need them yet.\n * A regex could get you 80% of the way. What's your tolerance for edge cases?\n * (Nested functions? Async? Arrow functions? Methods in classes?)\n *\n * Start small. Get it working for the simple case.\n * Then ask: what broke? And fix that case.\n * That's how you learn what you actually need.\n *\n * don-socratic asks (again):\n * What does a @rhizome stub comment look like? You answered: //@rhizome, #@rhizome, etc.\n * Good. So write the regex. Then test it on your code. Does it find them?\n *\n * TODO: Write regex to find @rhizome stub comments (you know how)\n * TODO: Extract line number and function signature on next line\n * TODO: What breaks first? Fix that. Then the next thing.\n * TODO: Only then: do I need a proper parser, or is regex enough?\n */\nexport function findStubComments(code: string, language: string): Array<{\n\tline: number;\n\tfunctionName: string;\n\tsignature: string;        // The full function signature from next line(s)\n\tparams: string;           // Just the params: \"(x, y)\" or \"(x: number, y?: string)\"\n\treturnType: string | null; // Return type if present, else null\n}> {\n\tthrow new Error('Not implemented');\n\n\t// WHAT DOES @RHIZOME STUB LOOK LIKE?\n\t//\n\t// Comment format (language-specific):\n\t//   // @rhizome stub       (TypeScript/JavaScript)\n\t//   # @rhizome stub       (Python)\n\t//   /* @rhizome stub */   (Block comment, any language)\n\t//\n\t// Regex pattern (language-agnostic):\n\t//   /(@rhizome\\s+stub)/i\n\t//\n\t// WHERE IS THE FUNCTION SIGNATURE?\n\t//   - ASSUMPTION (for v1): signature is on the NEXT line after @rhizome stub\n\t//   - TOLERANCE: zero or one blank line is OK, but not multiple blank lines\n\t//   - WHY: Keeps @rhizome stub marker tight to the function it describes\n\t//\n\t// IMPLEMENTATION STRATEGY:\n\t//   1. Split code into lines\n\t//   2. Find lines matching @rhizome stub pattern (regex is fine, you know how)\n\t//   3. Get line number + next line(s) until you find a function keyword\n\t//   4. Extract signature from that line\n\t//   5. Parse the signature to get params and return type\n\t//\n\t// EDGE CASES: START WITH THESE, SKIP THE REST FOR NOW\n\t//   \u2713 Top-level function declarations (function name() {...})\n\t//   \u2713 Arrow functions (const name = (...) => {...})\n\t//   \u2713 Async functions (async function name() {...})\n\t//   \u2717 Nested functions (skip for now\u2014add if it breaks)\n\t//   \u2717 Methods in classes (skip for now\u2014add if it breaks)\n\t//\n\t// PARSER CHOICE: REGEX OR AST?\n\t//   - START WITH REGEX. You can extract function signature with a simple pattern.\n\t//   - REGEX IS 80% SOLUTION: works for the cases above.\n\t//   - ONLY USE AST (@babel/parser, Python ast) if regex breaks on real code.\n\t\t//   - AST ADDS COMPLEXITY: don't pay that cost until you need it.\n\t//\n\t// REGEX PATTERN FOR FUNCTION SIGNATURE:\n\t//   TypeScript/JavaScript:\n\t//     /^(export\\s+)?(async\\s+)?(function\\s+)?(\\w+)\\s*(\\([^)]*\\))(\\s*:\\s*\\w+)?/\n\t//     Captures: exportKeyword, asyncKeyword, functionKeyword, name, params, returnType\n\t//\n\t//   Python:\n\t//     /^(async\\s+)?def\\s+(\\w+)\\s*(\\([^)]*\\))(\\s*->\\s*\\w+)?:/\n\t//     Captures: asyncKeyword, name, params, returnType\n}\n\n/**\n * Insert stub into code at specified location\n *\n * don-socratic asks:\n * You've found where to insert. But HOW?\n * Do you replace the entire function signature?\n * Do you keep what was there and add to it?\n * How do you preserve indentation?\n * How do you handle line endings?\n *\n * TODO: Implement stub insertion\n */\nexport function insertStub(\n\tcode: string,\n\tline: number,           // 0-indexed line number where @rhizome stub comment is\n\tstub: string,           // Generated stub code from generateStub()\n\tlanguage: string,\n): string {\n\tthrow new Error('Not implemented');\n\n\t// INSERTION STRATEGY:\n\t//   - Don't replace the function signature if it exists\n\t//   - Add the stub body INSIDE the function (between { and })\n\t//   - Or for Python: after the function def line, before any docstring\n\t//\n\t// STEP-BY-STEP:\n\t//   1. Find the opening brace/colon on the signature line\n\t//   2. Get the indentation from that line\n\t//   3. Insert stub code with matching indentation\n\t//   4. Preserve the closing brace/endif\n\t//\n\t// EXAMPLE - TypeScript (before):\n\t//   // @rhizome stub\n\t//   function getName(x: number): string\n\t//\n\t// EXAMPLE - TypeScript (after):\n\t//   // @rhizome stub\n\t//   function getName(x: number): string {\n\t//     throw new Error('Not implemented: getName');\n\t//   }\n\t//\n\t// EXAMPLE - Python (before):\n\t//   # @rhizome stub\n\t//   def get_name(x: int) -> str:\n\t//\n\t// EXAMPLE - Python (after):\n\t//   # @rhizome stub\n\t//   def get_name(x: int) -> str:\n\t//     raise NotImplementedError('get_name')\n\t//\n\t// INDENTATION HANDLING:\n\t//   - Get the indentation level from the function signature line\n\t//   - TypeScript: add 1 indent level (usually 1 tab or 2-4 spaces)\n\t//   - Python: add 1 indent level (usually 4 spaces)\n\t//   - Preserve the user's original indentation style (tabs vs spaces)\n\t//\n\t// LINE ENDING HANDLING:\n\t//   - Detect the line ending style in the original code: \\n or \\r\\n\n\t//   - Use the same style when inserting\n\t//   - Simple: detect() { return code.includes('\\r\\n') ? '\\r\\n' : '\\n'; }\n\t//\n\t// OFF-BY-ONE ERRORS (THE TRAP):\n\t//   - lines array is 0-indexed, but split('\\n') gives you that\n\t//   - Don't accidentally include/exclude the @rhizome stub line itself\n\t//   - Don't accidentally insert at wrong line (use the signature line, not the comment)\n\t//   - Test with known input + expected output before you trust it\n\t//\n\t// TESTS TO WRITE FIRST (before implementing):\n\t//   - Insert stub at line 0 (beginning of file)\n\t//   - Insert stub in the middle of file with other functions\n\t//   - Preserve indentation (tabs and spaces separately)\n\t//   - Preserve line endings (\\n and \\r\\n separately)\n\t//   - Handle TypeScript and Python separately\n}\n"],
  "mappings": "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",
  "names": []
}
