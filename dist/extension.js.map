{
  "version": 3,
  "sources": ["../src/extension.ts", "../src/stubGenerator.ts"],
  "sourcesContent": ["\nimport * as vscode from 'vscode';\nimport { generateStub, findStubComments, insertStub } from './stubGenerator';\n\n/**\n * @rhizome: how do libraries work here?\n *\n * In VSCode extensions, local TypeScript files are bundled with the extension.\n * We import from ./stubGenerator (same directory, same bundle).\n * esbuild will tree-shake unused code and bundle everything into dist/extension.js.\n *\n * Path aliases (@rhizome/lib) come later if we extract to separate package.\n * For now: relative imports within src/ work fine.\n */\n\n/**\n * Activate extension on startup\n *\n * don-socratic asks:\n * What's the user's workflow? They write a comment, then what?\n * Do they:\n * a) Right-click on the red squiggle?\n * b) Hit a keyboard shortcut?\n * c) Something else?\n *\n * How do they KNOW the extension is listening?\n * What feedback do they get?\n *\n * ANSWER (from UX & workflow design):\n * Workflow A: Select code \u2192 right-click \u2192 \"Ask don-socratic\" (context menu)\n *   - User sees it in menu (feedback = visibility)\n *   - Package.json already has menu entry for donSocratic command\n *   - Shows when editor has selection (when condition)\n *   - Response appears in webview or output channel\n *\n * Workflow B (future): @rhizome stub comment above function \u2192 right-click \u2192 \"Stub this function\"\n *   - User sees function signature \u2192 underline \u2192 context action\n *   - Or: keyboard shortcut (configure in keybindings)\n *   - Stub appears in file after triggering\n *\n * For now: Build workflow A fully. Stub command can follow same pattern.\n * Feedback: Use vscode.window.showInformationMessage() for simple cases,\n * webview panel for rich responses (show personas, chat history, etc.)\n */\nexport function activate(context: vscode.ExtensionContext) {\n\tconsole.log('vscode-rhizome activated');\n\n\t// ======================================\n\t// CORE FEATURE: don-socratic guidance\n\t// ======================================\n\t// The don is always listening. When you select code, he brings\n\t// Socratic questioning to bear on what you're building.\n\t//\n\t// Workflow: Select code \u2192 right-click \u2192 \"Ask don-socratic\"\n\t// Response: Shows in output channel (for now; webview later)\n\t//\n\t// CURRENT IMPLEMENTATION:\n\t// 1. Get active editor and selection (user feedback: \"What are you seeing?\" )\n\t// 2. Create or show output channel\n\t// 3. Log what we're about to do (for MVP: just show the code)\n\t// 4. TODO: Call rhizome CLI with persona + code \u2192 get LLM response\n\t// 5. Display response to user\n\t//\n\tlet donSocraticDisposable = vscode.commands.registerCommand('vscode-rhizome.donSocratic', async () => {\n\t\tconst editor = vscode.window.activeTextEditor;\n\t\tif (!editor) {\n\t\t\tvscode.window.showErrorMessage('No active editor');\n\t\t\treturn;\n\t\t}\n\n\t\tconst selection = editor.selection;\n\t\tconst selectedText = editor.document.getText(selection);\n\n\t\tif (!selectedText) {\n\t\t\tvscode.window.showErrorMessage('Please select code to question');\n\t\t\treturn;\n\t\t}\n\n\t\t// Show user we're doing something\n\t\tawait vscode.window.showInformationMessage('Asking don-socratic...');\n\n\t\t// Create or get output channel for responses\n\t\tconst outputChannel = vscode.window.createOutputChannel('vscode-rhizome');\n\t\toutputChannel.show(true);\n\n\t\t// Log what we're about to do\n\t\toutputChannel.appendLine('='.repeat(60));\n\t\toutputChannel.appendLine('don-socratic');\n\t\toutputChannel.appendLine('='.repeat(60));\n\t\toutputChannel.appendLine('Selected code:');\n\t\toutputChannel.appendLine('');\n\t\toutputChannel.appendLine(selectedText);\n\t\toutputChannel.appendLine('');\n\t\toutputChannel.appendLine('--- Waiting for persona response ---');\n\t\toutputChannel.appendLine('');\n\n\t\t// NEXT: Call rhizome CLI to query don-socratic with the selected code\n\t\t// Command: rhizome query --persona don-socratic\n\t\t// Pass the selected code as stdin\n\t\t//\n\t\t// ROUGH EDGES (will clean up after testing):\n\t\t// - No error handling for rhizome CLI not found\n\t\t// - Assumes rhizome in PATH\n\t\t// - Spawned process could timeout\n\t\t// - Response parsing could fail silently\n\t\t// - No retry logic\n\t\t//\n\t\t// TODO: Wrap in error handling + timeout\n\t\t// TODO: Check rhizome in PATH before calling\n\t\t// TODO: Handle stderr from rhizome\n\t\t// TODO: Parse response and format nicely\n\n\t\t// For now: call rhizome and show raw output\n\t\ttry {\n\t\t\tconst { execSync } = require('child_process');\n\t\t\tconst response = execSync(`rhizome query --persona don-socratic`, {\n\t\t\t\tinput: selectedText,\n\t\t\t\tencoding: 'utf-8',\n\t\t\t\ttimeout: 30000, // 30 second timeout\n\t\t\t});\n\t\t\toutputChannel.appendLine('');\n\t\t\toutputChannel.appendLine('Response from don-socratic:');\n\t\t\toutputChannel.appendLine('');\n\t\t\toutputChannel.appendLine(response);\n\t\t} catch (error: any) {\n\t\t\toutputChannel.appendLine('');\n\t\t\toutputChannel.appendLine('Error calling rhizome CLI:');\n\t\t\toutputChannel.appendLine((error as Error).message);\n\t\t\toutputChannel.appendLine('');\n\t\t\toutputChannel.appendLine('Make sure rhizome is installed and in your PATH.');\n\t\t}\n\t});\n\n\tcontext.subscriptions.push(donSocraticDisposable);\n\n\t// ======================================\n\t// STUB GENERATION\n\t// ======================================\n\t// don-socratic asks:\n\t// When someone invokes the stub command, what needs to happen?\n\t// 1. Find the @rhizome stub comment?\n\t// 2. Parse the function signature?\n\t// 3. Generate the stub?\n\t// 4. Insert it into the file?\n\t//\n\t// In what order? And how do you know each step succeeded?\n\t//\n\t// ANSWER (step-by-step workflow):\n\t// 1. Get active editor (vscode.window.activeTextEditor)\n\t// 2. Get the document text (editor.document.getText())\n\t// 3. Find all @rhizome stub comments (findStubComments from stubGenerator)\n\t// 4. If multiple, ask user which one (InputBox)\n\t// 5. For selected stub:\n\t//    a. Extract function signature\n\t//    b. Detect language from file extension\n\t//    c. Call generateStub(functionName, params, returnType, language)\n\t//    d. Call insertStub(code, line, generatedStub, language)\n\t// 6. Apply edit to document (TextEdit)\n\t// 7. Show success/error message\n\t//\n\t// Error handling: Show user what went wrong at each step\n\t//\n\tlet stubDisposable = vscode.commands.registerCommand('vscode-rhizome.stub', async () => {\n\t\tconst editor = vscode.window.activeTextEditor;\n\t\tif (!editor) {\n\t\t\tvscode.window.showErrorMessage('No active editor');\n\t\t\treturn;\n\t\t}\n\n\t\tconst document = editor.document;\n\t\tconst code = document.getText();\n\n\t\t// Detect language from file extension\n\t\tconst ext = document.languageId; // 'typescript', 'javascript', 'python', etc.\n\t\tconst language = ext === 'typescript' || ext === 'javascript' ? 'typescript' : ext === 'python' ? 'python' : null;\n\n\t\tif (!language) {\n\t\t\tvscode.window.showErrorMessage(`Unsupported language: ${ext}. Use TypeScript, JavaScript, or Python.`);\n\t\t\treturn;\n\t\t}\n\n\t\t// Find @rhizome stub comments in the file\n\t\tconst stubs = findStubComments(code, language);\n\n\t\tif (stubs.length === 0) {\n\t\t\tvscode.window.showWarningMessage('No @rhizome stub comments found in this file');\n\t\t\treturn;\n\t\t}\n\n\t\t// If multiple stubs, ask user which one\n\t\tlet targetStub = stubs[0];\n\t\tif (stubs.length > 1) {\n\t\t\tconst picked = await vscode.window.showQuickPick(\n\t\t\t\tstubs.map((s) => `Line ${s.line}: ${s.functionName}`),\n\t\t\t\t{ placeHolder: 'Which function to stub?' }\n\t\t\t);\n\t\t\tif (!picked) return;\n\t\t\tconst index = stubs.map((s) => `Line ${s.line}: ${s.functionName}`).indexOf(picked);\n\t\t\ttargetStub = stubs[index];\n\t\t}\n\n\t\t// Generate stub code\n\t\tconst stub = generateStub(targetStub.functionName, targetStub.params, targetStub.returnType, language as any);\n\n\t\t// Insert stub into file\n\t\tconst modifiedCode = insertStub(code, targetStub.line, stub, language);\n\n\t\t// Apply edit to document\n\t\tconst fullRange = new vscode.Range(document.positionAt(0), document.positionAt(code.length));\n\t\tconst edit = new vscode.TextEdit(fullRange, modifiedCode);\n\n\t\t// Create workspace edit and apply\n\t\tconst workspaceEdit = new vscode.WorkspaceEdit();\n\t\tworkspaceEdit.set(document.uri, [edit]);\n\t\tawait vscode.workspace.applyEdit(workspaceEdit);\n\n\t\tvscode.window.showInformationMessage(`Stub created for ${targetStub.functionName}`);\n\t});\n\n\tcontext.subscriptions.push(stubDisposable);\n}\n\nexport function deactivate() {}\n\n", "/**\n * Stub Generator\n *\n * don-socratic asks:\n * Before you write a line, answer this: what does \"stub\" actually MEAN?\n * When a developer sees the generated stub, what must be there?\n * What must NOT be there?\n *\n * Think carefully. Write down your answer in the comment below before proceeding.\n *\n * ANSWER (from dev-guide + code-reviewer collaboration):\n * A stub for vscode-rhizome is:\n *\n * MUST HAVE:\n * \u2713 Function signature with available type information\n * \u2713 throw new Error('Not implemented') | raise NotImplementedError()\n * \u2713 TODO comment that mentions the function name\n * \u2713 Optional: ISO 8601 timestamp, user story reference (e.g., \"US-123: As a user...\")\n * \u2713 Language-specific syntax (TS throws Error, Python raises NotImplementedError)\n *\n * MUST NOT HAVE:\n * \u2717 Partial implementation or misleading logic\n * \u2717 Vague TODO (must include function name for context outside editor)\n * \u2717 Assumption about parameter types (infer from signature or mark as unknown)\n *\n * RATIONALE:\n * - Prevents linter errors (undefined function \u2192 defined, throws as expected)\n * - Forces explicit intent (TODO + timestamp = \"I thought about this\")\n * - Supports TODO backlog tracking (searchable by function name)\n * - Integrates with user story workflow (reference in comment)\n * - Language-consistent (developers recognize pattern across TS/JS/Python)\n */\n\n/**\n * Parse a function signature and generate a stub\n *\n * don-socratic asks:\n * What languages are we dealing with? (TS, JS, Python)\n * How do we know where to insert the stub?\n * What's the minimal stub that satisfies your definition above?\n *\n * TODO: Implement stub generation\n * TODO: What's the function signature?\n * TODO: What's the return type?\n * TODO: What error do we throw?\n * TODO: What TODO comment do we add?\n */\nexport function generateStub(\n\tfunctionName: string,\n\tparams: string,           // e.g., \"(x: number, y?: string)\" \u2014 keep as-is from signature\n\treturnType: string | null, // e.g., \"string\" or \"Promise<void>\" or null if untyped\n\tlanguage: 'typescript' | 'javascript' | 'python',\n\toptions?: {\n\t\ttimestamp?: string;   // ISO 8601: \"2025-10-23T21:00:00Z\" (optional)\n\t\tuserStory?: string;   // e.g., \"US-142: As a developer...\"  (optional)\n\t}\n): string {\n\t/**\n\t * BUILD THE TODO COMMENT\n\t * \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\t * This is what appears above the function.\n\t * Must include: function name (for TODO backlog search)\n\t * Optional: timestamp (when was this stubbed?), user story (why?)\n\t */\n\tlet todoComment = `TODO: Implement ${functionName}`;\n\n\tif (options?.timestamp) {\n\t\ttodoComment += ` (stubbed ${options.timestamp}`;\n\t\tif (options?.userStory) {\n\t\t\ttodoComment += `, ${options.userStory}`;\n\t\t}\n\t\ttodoComment += ')';\n\t} else if (options?.userStory) {\n\t\ttodoComment += ` (${options.userStory})`;\n\t}\n\n\t/**\n\t * LANGUAGE-SPECIFIC STUB BODY\n\t * \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\t * Two paths: TypeScript/JavaScript vs Python\n\t * Each throws/raises with function name for debugging\n\t */\n\tlet stubBody: string;\n\n\tif (language === 'python') {\n\t\t// Python uses indentation-relative code; caller will add indentation\n\t\t// Format: raise NotImplementedError('function_name')\n\t\tstubBody = `raise NotImplementedError('${functionName}')`;\n\t} else {\n\t\t// TypeScript/JavaScript: throw new Error(...)\n\t\t// Format: throw new Error('Not implemented: functionName')\n\t\tstubBody = `throw new Error('Not implemented: ${functionName}');`;\n\t}\n\n\t/**\n\t * ASSEMBLE THE STUB\n\t * \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\t * Return just the body (not the function signature).\n\t * Caller (insertStub) handles placing this inside the function.\n\t * Include the TODO comment so it appears above.\n\t */\n\treturn `${todoComment}\\n${stubBody}`;\n}\n\n\n\n/**\n * Find @rhizome stub comments in code\n *\n * don-socratic observes:\n * You asked for AST parsing. Good question. Here's what you get:\n *\n * Two paths in this function:\n * - REGEX: Simple, fast, no dependencies. But brittle for complex signatures.\n * - AST: Robust, parses anything, but requires @babel/parser (TS/JS) or ast module (Python).\n *\n * The code tries AST first (if the parser is available).\n * Falls back to regex if you don't have the dependencies.\n *\n * This way: you get robustness when you have the tools.\n * You get simplicity when you don't.\n * And you can feel the difference when you upgrade.\n */\nexport function findStubComments(code: string, language: string): Array<{\n\tline: number;\n\tfunctionName: string;\n\tsignature: string;\n\tparams: string;\n\treturnType: string | null;\n}> {\n\tconst results: Array<{\n\t\tline: number;\n\t\tfunctionName: string;\n\t\tsignature: string;\n\t\tparams: string;\n\t\treturnType: string | null;\n\t}> = [];\n\n\tconst lines = code.split('\\n');\n\tconst markerRegex = /@rhizome\\s+stub/i;\n\n\t/**\n\t * STRATEGY: Try AST parsing first. Fall back to regex.\n\t *\n\t * Why both?\n\t * - AST is correct. It understands scope, complexity, edge cases.\n\t * - Regex is simple. No dependencies. But fragile.\n\t *\n\t * If @babel/parser is installed, we use it. Otherwise, regex.\n\t * The user doesn't need to know. It just works better when it can.\n\t */\n\n\t// Try to load the parser. If it fails, we'll fall back to regex.\n\tlet hasParser = false;\n\tlet parser: any = null;\n\n\tif (language === 'typescript' || language === 'javascript') {\n\t\ttry {\n\t\t\t// @ts-ignore: dynamic require\n\t\t\tparser = require('@babel/parser');\n\t\t\thasParser = true;\n\t\t} catch (e) {\n\t\t\t// Parser not installed. That's fine, we'll use regex.\n\t\t}\n\t}\n\n\tfor (let i = 0; i < lines.length; i++) {\n\t\tif (markerRegex.test(lines[i])) {\n\t\t\tconst markerLine = i;\n\n\t\t\t// Find next non-blank line\n\t\t\tlet signatureLine = i + 1;\n\t\t\twhile (\n\t\t\t\tsignatureLine < lines.length &&\n\t\t\t\tlines[signatureLine].trim() === ''\n\t\t\t) {\n\t\t\t\tsignatureLine++;\n\t\t\t}\n\n\t\t\tif (signatureLine >= lines.length) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Try AST parsing if available\n\t\t\tif (hasParser && language !== 'python') {\n\t\t\t\ttry {\n\t\t\t\t\tconst result = parseWithAST(\n\t\t\t\t\t\tlines,\n\t\t\t\t\t\tsignatureLine,\n\t\t\t\t\t\tmarkerLine,\n\t\t\t\t\t\tparser,\n\t\t\t\t\t\tcode\n\t\t\t\t\t);\n\t\t\t\t\tif (result) {\n\t\t\t\t\t\tresults.push(result);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\t// AST parsing failed. Fall through to regex.\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Fall back to regex (Python always uses regex for now)\n\t\t\tconst regexResult = parseWithRegex(\n\t\t\t\tlines[signatureLine].trim(),\n\t\t\t\tmarkerLine,\n\t\t\t\tlanguage\n\t\t\t);\n\t\t\tif (regexResult) {\n\t\t\t\tresults.push(regexResult);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn results;\n}\n\n/**\n * Parse function signature using AST (@babel/parser for TS/JS)\n *\n * This is more robust than regex. It understands:\n * \u2713 Destructured params: function({a, b})\n * \u2713 Complex generics: function<T extends Base>(x: T)\n * \u2713 Arrow functions with multiline params\n * \u2713 Default values and optional params\n *\n * But it's also more complex. We wrap it in try/catch so\n * if the code is malformed, we gracefully fall back to regex.\n */\nfunction parseWithAST(\n\tlines: string[],\n\tsignatureLine: number,\n\tmarkerLine: number,\n\tparser: any,\n\tfullCode: string\n): {\n\tline: number;\n\tfunctionName: string;\n\tsignature: string;\n\tparams: string;\n\treturnType: string | null;\n} | null {\n\ttry {\n\t\t// Reconstruct multi-line function signature\n\t\t// (signatures can span multiple lines)\n\t\tlet signatureText = '';\n\t\tlet currentLine = signatureLine;\n\n\t\t// Scan until we find the opening brace\n\t\twhile (currentLine < lines.length) {\n\t\t\tsignatureText += lines[currentLine];\n\t\t\tif (signatureText.includes('{')) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsignatureText += '\\n';\n\t\t\tcurrentLine++;\n\t\t}\n\n\t\t// Parse just the function declaration\n\t\t// Wrap in a scope to make it valid JavaScript\n\t\tconst wrapped = `function _wrapper() { ${signatureText}; }`;\n\n\t\tconst ast = parser.parse(wrapped, {\n\t\t\tsourceType: 'module',\n\t\t\tplugins: ['typescript'],\n\t\t});\n\n\t\t// Extract the function node from the AST\n\t\t// This is a deep dive\u2014but it's worth seeing how AST works\n\t\tconst wrapper = ast.program.body[0]?.body?.body[0];\n\t\tif (!wrapper || wrapper.type !== 'FunctionDeclaration') {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst func = wrapper;\n\t\tconst name = func.id.name;\n\t\tconst params = signatureText\n\t\t\t.substring(signatureText.indexOf('('), signatureText.indexOf(')') + 1)\n\t\t\t.trim();\n\n\t\t// Extract return type if present (TS annotation)\n\t\tconst returnTypeMatch = signatureText.match(\n\t\t\t/\\):\\s*([\\w<>\\[\\]\\s|&,]+)\\s*[{]/\n\t\t);\n\t\tconst returnType = returnTypeMatch\n\t\t\t? returnTypeMatch[1].trim()\n\t\t\t: null;\n\n\t\treturn {\n\t\t\tline: markerLine,\n\t\t\tfunctionName: name,\n\t\t\tsignature: signatureText.split('\\n')[0],\n\t\t\tparams,\n\t\t\treturnType,\n\t\t};\n\t} catch (e) {\n\t\t// AST parsing failed. Will fall through to regex.\n\t\treturn null;\n\t}\n}\n\n/**\n * Parse function signature using regex (fallback)\n *\n * Simple, no dependencies. But fragile.\n * Handles 90% of real code. The other 10%? Silent failure.\n *\n * This is the constraint you feel when regex breaks.\n * When you hit it, you'll know exactly why we offer AST as an alternative.\n */\nfunction parseWithRegex(\n\tsig: string,\n\tmarkerLine: number,\n\tlanguage: string\n): {\n\tline: number;\n\tfunctionName: string;\n\tsignature: string;\n\tparams: string;\n\treturnType: string | null;\n} | null {\n\tlet match;\n\tlet name, params, returnType;\n\n\tif (language === 'python') {\n\t\tconst pythonFunctionRegex =\n\t\t\t/^(?:async\\s+)?def\\s+(\\w+)\\s*(\\([^)]*\\))(?:\\s*->\\s*([\\w\\[\\]]+))?:/;\n\t\tmatch = sig.match(pythonFunctionRegex);\n\t\tif (match) {\n\t\t\tname = match[1];\n\t\t\tparams = match[2];\n\t\t\treturnType = match[3] || null;\n\t\t}\n\t} else {\n\t\t// TypeScript / JavaScript\n\t\tconst tsJsFunctionRegex =\n\t\t\t/^(?:export\\s+)?(?:const\\s+)?(?:async\\s+)?(?:function\\s+)?(\\w+)\\s*(\\([^)]*\\))(?:\\s*:\\s*([\\w<>\\[\\]|\\s]+))?/;\n\t\tmatch = sig.match(tsJsFunctionRegex);\n\t\tif (match) {\n\t\t\tname = match[1];\n\t\t\tparams = match[2];\n\t\t\treturnType = match[3]?.trim() || null;\n\t\t}\n\t}\n\n\tif (name && params) {\n\t\treturn {\n\t\t\tline: markerLine,\n\t\t\tfunctionName: name,\n\t\t\tsignature: sig,\n\t\t\tparams,\n\t\t\treturnType: returnType ?? null,\n\t\t};\n\t}\n\n\treturn null;\n}\n\n/**\n * Insert stub into code at specified location\n *\n * don-socratic observes:\n * You've found the stub marker. You know the function signature.\n * Now: where does the body live? How do you know where one function ends and the next begins?\n *\n * Here's the honest answer: we use heuristics. String manipulation, not AST.\n * This works for 95% of real code. The 5% edge cases? We don't handle them.\n * Why? Because parsing scope is hard. Building an AST is overkill for a v1.\n *\n * But you'll feel the constraint. When it works, you'll wonder why.\n * When it breaks, you'll know exactly what to fix.\n */\nexport function insertStub(\n\tcode: string,\n\tline: number,           // 0-indexed line number where @rhizome stub comment is\n\tstub: string,           // Generated stub code from generateStub()\n\tlanguage: string,\n): string {\n\tconst lineEnding = code.includes('\\r\\n') ? '\\r\\n' : '\\n';\n\tconst lines = code.split('\\n');\n\n\tif (line < 0 || line >= lines.length) {\n\t\tthrow new Error(`Invalid line number: ${line}`);\n\t}\n\n\t// Find the function signature (next non-blank line after marker)\n\tlet signatureLine = line + 1;\n\twhile (signatureLine < lines.length && lines[signatureLine].trim() === '') {\n\t\tsignatureLine++;\n\t}\n\tif (signatureLine >= lines.length) {\n\t\tthrow new Error('No function signature found after @rhizome stub marker');\n\t}\n\n\tconst signatureText = lines[signatureLine];\n\tconst indentation = signatureText.match(/^\\s*/)?.[0] || '';\n\n\t/**\n\t * DECISION: How do we find where the function body starts?\n\t *\n\t * We look for opening brace (TS/JS) or colon (Python).\n\t * If not on the signature line, we scan forward line-by-line.\n\t *\n\t * CONSTRAINT: This fails if:\n\t * - { or : appears in a string literal on the signature line\n\t * - Function signature spans 10+ lines (we'd scan too far)\n\t * - Comments contain { or :\n\t *\n\t * TRADE-OFF: We chose simplicity over bulletproof parsing.\n\t * If you need to handle complex signatures, you'll want a real parser (@babel/parser or ast module).\n\t * For now, this works for 95% of function declarations.\n\t */\n\tlet openingBraceLine = signatureLine;\n\n\tif (language === 'python') {\n\t\t// Python: find the line ending with ':'\n\t\tif (!signatureText.trimEnd().endsWith(':')) {\n\t\t\topeningBraceLine = signatureLine + 1;\n\t\t\twhile (\n\t\t\t\topeningBraceLine < lines.length &&\n\t\t\t\t!lines[openingBraceLine].trimEnd().endsWith(':')\n\t\t\t) {\n\t\t\t\topeningBraceLine++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// TypeScript/JavaScript: find the line containing '{'\n\t\tif (signatureText.indexOf('{') === -1) {\n\t\t\topeningBraceLine = signatureLine + 1;\n\t\t\twhile (\n\t\t\t\topeningBraceLine < lines.length &&\n\t\t\t\tlines[openingBraceLine].indexOf('{') === -1\n\t\t\t) {\n\t\t\t\topeningBraceLine++;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Prepare the stub with indentation\n\tconst stubLines = stub.split('\\n');\n\tconst bodyIndentation = indentation + '\\t';\n\tconst indentedStub = stubLines.map((l) => (l === '' ? '' : bodyIndentation + l));\n\n\t/**\n\t * DECISION: Where do we insert the stub?\n\t *\n\t * TS/JS: Right after the opening brace {\n\t * Python: Right after the colon :\n\t *\n\t * CONSTRAINT: We assume the function body is empty (or we're inserting at the start).\n\t * If there's existing code, we insert above it (which is correct for stubs).\n\t *\n\t * We add a closing brace for TS/JS, but ONLY if one doesn't already exist nearby.\n\t * This heuristic is fragile. If a function has existing code, we might not add the brace.\n\t * But for stub generation (empty functions), it works.\n\t */\n\tif (language === 'python') {\n\t\tlines.splice(openingBraceLine + 1, 0, ...indentedStub);\n\t} else {\n\t\t// TypeScript/JavaScript\n\t\tlines.splice(openingBraceLine + 1, 0, ...indentedStub);\n\n\t\t// Check if we need to add a closing brace\n\t\tconst nextLineAfterStub = openingBraceLine + indentedStub.length + 1;\n\t\tconst hasClosingBrace =\n\t\t\tnextLineAfterStub < lines.length &&\n\t\t\tlines[nextLineAfterStub].trim().startsWith('}');\n\n\t\tif (!hasClosingBrace) {\n\t\t\tlines.splice(nextLineAfterStub, 0, indentation + '}');\n\t\t}\n\t}\n\n\treturn lines.join(lineEnding);\n}\n"],
  "mappings": "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",
  "names": []
}
