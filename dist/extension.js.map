{
  "version": 3,
  "sources": ["../src/extension.ts", "../src/stubGenerator.ts"],
  "sourcesContent": ["\nimport * as vscode from 'vscode';\nimport { generateStub, findStubComments, insertStub } from './stubGenerator';\n\n/**\n * @rhizome: how do libraries work here?\n *\n * In VSCode extensions, local TypeScript files are bundled with the extension.\n * We import from ./stubGenerator (same directory, same bundle).\n * esbuild will tree-shake unused code and bundle everything into dist/extension.js.\n *\n * Path aliases (@rhizome/lib) come later if we extract to separate package.\n * For now: relative imports within src/ work fine.\n */\n\n/**\n * Activate extension on startup\n *\n * don-socratic asks:\n * What's the user's workflow? They write a comment, then what?\n * Do they:\n * a) Right-click on the red squiggle?\n * b) Hit a keyboard shortcut?\n * c) Something else?\n *\n * How do they KNOW the extension is listening?\n * What feedback do they get?\n *\n * ANSWER (from UX & workflow design):\n * Workflow A: Select code \u2192 right-click \u2192 \"Ask don-socratic\" (context menu)\n *   - User sees it in menu (feedback = visibility)\n *   - Package.json already has menu entry for donSocratic command\n *   - Shows when editor has selection (when condition)\n *   - Response appears in webview or output channel\n *\n * Workflow B (future): @rhizome stub comment above function \u2192 right-click \u2192 \"Stub this function\"\n *   - User sees function signature \u2192 underline \u2192 context action\n *   - Or: keyboard shortcut (configure in keybindings)\n *   - Stub appears in file after triggering\n *\n * For now: Build workflow A fully. Stub command can follow same pattern.\n * Feedback: Use vscode.window.showInformationMessage() for simple cases,\n * webview panel for rich responses (show personas, chat history, etc.)\n */\nexport function activate(context: vscode.ExtensionContext) {\n\tconsole.log('vscode-rhizome activated');\n\n\t// ======================================\n\t// CORE FEATURE: don-socratic guidance\n\t// ======================================\n\t// The don is always listening. When you select code, he brings\n\t// Socratic questioning to bear on what you're building.\n\t//\n\t// Workflow: Select code \u2192 right-click \u2192 \"Ask don-socratic\"\n\t// Response: Shows in output channel (for now; webview later)\n\t//\n\t// CURRENT IMPLEMENTATION:\n\t// 1. Get active editor and selection (user feedback: \"What are you seeing?\" )\n\t// 2. Create or show output channel\n\t// 3. Log what we're about to do (for MVP: just show the code)\n\t// 4. TODO: Call rhizome CLI with persona + code \u2192 get LLM response\n\t// 5. Display response to user\n\t//\n\tlet donSocraticDisposable = vscode.commands.registerCommand('vscode-rhizome.donSocratic', async () => {\n\t\tconst editor = vscode.window.activeTextEditor;\n\t\tif (!editor) {\n\t\t\tvscode.window.showErrorMessage('No active editor');\n\t\t\treturn;\n\t\t}\n\n\t\tconst selection = editor.selection;\n\t\tconst selectedText = editor.document.getText(selection);\n\n\t\tif (!selectedText) {\n\t\t\tvscode.window.showErrorMessage('Please select code to question');\n\t\t\treturn;\n\t\t}\n\n\t\t// Show user we're doing something\n\t\tawait vscode.window.showInformationMessage('Asking don-socratic...');\n\n\t\t// Create or get output channel for responses\n\t\tconst outputChannel = vscode.window.createOutputChannel('vscode-rhizome');\n\t\toutputChannel.show(true);\n\n\t\t// Log what we're about to do\n\t\toutputChannel.appendLine('='.repeat(60));\n\t\toutputChannel.appendLine('don-socratic');\n\t\toutputChannel.appendLine('='.repeat(60));\n\t\toutputChannel.appendLine('Selected code:');\n\t\toutputChannel.appendLine('');\n\t\toutputChannel.appendLine(selectedText);\n\t\toutputChannel.appendLine('');\n\t\toutputChannel.appendLine('--- Waiting for persona response ---');\n\t\toutputChannel.appendLine('');\n\n\t\t// NEXT: Call rhizome CLI to query don-socratic with the selected code\n\t\t// Command: rhizome query --persona don-socratic\n\t\t// Pass the selected code as stdin\n\t\t//\n\t\t// ROUGH EDGES (will clean up after testing):\n\t\t// - No error handling for rhizome CLI not found\n\t\t// - Assumes rhizome in PATH\n\t\t// - Spawned process could timeout\n\t\t// - Response parsing could fail silently\n\t\t// - No retry logic\n\t\t//\n\t\t// TODO: Wrap in error handling + timeout\n\t\t// TODO: Check rhizome in PATH before calling\n\t\t// TODO: Handle stderr from rhizome\n\t\t// TODO: Parse response and format nicely\n\n\t\t// For now: call rhizome and show raw output\n\t\ttry {\n\t\t\tconst { execSync } = require('child_process');\n\t\t\tconst response = execSync(`rhizome query --persona don-socratic`, {\n\t\t\t\tinput: selectedText,\n\t\t\t\tencoding: 'utf-8',\n\t\t\t\ttimeout: 30000, // 30 second timeout\n\t\t\t});\n\t\t\toutputChannel.appendLine('');\n\t\t\toutputChannel.appendLine('Response from don-socratic:');\n\t\t\toutputChannel.appendLine('');\n\t\t\toutputChannel.appendLine(response);\n\t\t} catch (error: any) {\n\t\t\toutputChannel.appendLine('');\n\t\t\toutputChannel.appendLine('Error calling rhizome CLI:');\n\t\t\toutputChannel.appendLine((error as Error).message);\n\t\t\toutputChannel.appendLine('');\n\t\t\toutputChannel.appendLine('Make sure rhizome is installed and in your PATH.');\n\t\t}\n\t});\n\n\tcontext.subscriptions.push(donSocraticDisposable);\n\n\t// ======================================\n\t// STUB GENERATION\n\t// ======================================\n\t// don-socratic asks:\n\t// When someone invokes the stub command, what needs to happen?\n\t// 1. Find the @rhizome stub comment?\n\t// 2. Parse the function signature?\n\t// 3. Generate the stub?\n\t// 4. Insert it into the file?\n\t//\n\t// In what order? And how do you know each step succeeded?\n\t//\n\t// ANSWER (step-by-step workflow):\n\t// 1. Get active editor (vscode.window.activeTextEditor)\n\t// 2. Get the document text (editor.document.getText())\n\t// 3. Find all @rhizome stub comments (findStubComments from stubGenerator)\n\t// 4. If multiple, ask user which one (InputBox)\n\t// 5. For selected stub:\n\t//    a. Extract function signature\n\t//    b. Detect language from file extension\n\t//    c. Call generateStub(functionName, params, returnType, language)\n\t//    d. Call insertStub(code, line, generatedStub, language)\n\t// 6. Apply edit to document (TextEdit)\n\t// 7. Show success/error message\n\t//\n\t// Error handling: Show user what went wrong at each step\n\t//\n\tlet stubDisposable = vscode.commands.registerCommand('vscode-rhizome.stub', async () => {\n\t\tconst editor = vscode.window.activeTextEditor;\n\t\tif (!editor) {\n\t\t\tvscode.window.showErrorMessage('No active editor');\n\t\t\treturn;\n\t\t}\n\n\t\tconst document = editor.document;\n\t\tconst code = document.getText();\n\n\t\t// Detect language from file extension\n\t\tconst ext = document.languageId; // 'typescript', 'javascript', 'python', etc.\n\t\tconst language = ext === 'typescript' || ext === 'javascript' ? 'typescript' : ext === 'python' ? 'python' : null;\n\n\t\tif (!language) {\n\t\t\tvscode.window.showErrorMessage(`Unsupported language: ${ext}. Use TypeScript, JavaScript, or Python.`);\n\t\t\treturn;\n\t\t}\n\n\t\t// Find @rhizome stub comments in the file\n\t\tconst stubs = findStubComments(code, language);\n\n\t\tif (stubs.length === 0) {\n\t\t\tvscode.window.showWarningMessage('No @rhizome stub comments found in this file');\n\t\t\treturn;\n\t\t}\n\n\t\t// If multiple stubs, ask user which one\n\t\tlet targetStub = stubs[0];\n\t\tif (stubs.length > 1) {\n\t\t\tconst picked = await vscode.window.showQuickPick(\n\t\t\t\tstubs.map((s) => `Line ${s.line}: ${s.functionName}`),\n\t\t\t\t{ placeHolder: 'Which function to stub?' }\n\t\t\t);\n\t\t\tif (!picked) return;\n\t\t\tconst index = stubs.map((s) => `Line ${s.line}: ${s.functionName}`).indexOf(picked);\n\t\t\ttargetStub = stubs[index];\n\t\t}\n\n\t\t// Generate stub code\n\t\tconst stub = generateStub(targetStub.functionName, targetStub.params, targetStub.returnType, language as any);\n\n\t\t// Insert stub into file\n\t\tconst modifiedCode = insertStub(code, targetStub.line, stub, language);\n\n\t\t// Apply edit to document\n\t\tconst fullRange = new vscode.Range(document.positionAt(0), document.positionAt(code.length));\n\t\tconst edit = new vscode.TextEdit(fullRange, modifiedCode);\n\n\t\t// Create workspace edit and apply\n\t\tconst workspaceEdit = new vscode.WorkspaceEdit();\n\t\tworkspaceEdit.set(document.uri, [edit]);\n\t\tawait vscode.workspace.applyEdit(workspaceEdit);\n\n\t\tvscode.window.showInformationMessage(`Stub created for ${targetStub.functionName}`);\n\t});\n\n\tcontext.subscriptions.push(stubDisposable);\n}\n\nexport function deactivate() {}\n\n", "/**\n * Stub Generator\n *\n * don-socratic asks:\n * Before you write a line, answer this: what does \"stub\" actually MEAN?\n * When a developer sees the generated stub, what must be there?\n * What must NOT be there?\n *\n * Think carefully. Write down your answer in the comment below before proceeding.\n *\n * ANSWER (from dev-guide + code-reviewer collaboration):\n * A stub for vscode-rhizome is:\n *\n * MUST HAVE:\n * \u2713 Function signature with available type information\n * \u2713 throw new Error('Not implemented') | raise NotImplementedError()\n * \u2713 TODO comment that mentions the function name\n * \u2713 Optional: ISO 8601 timestamp, user story reference (e.g., \"US-123: As a user...\")\n * \u2713 Language-specific syntax (TS throws Error, Python raises NotImplementedError)\n *\n * MUST NOT HAVE:\n * \u2717 Partial implementation or misleading logic\n * \u2717 Vague TODO (must include function name for context outside editor)\n * \u2717 Assumption about parameter types (infer from signature or mark as unknown)\n *\n * RATIONALE:\n * - Prevents linter errors (undefined function \u2192 defined, throws as expected)\n * - Forces explicit intent (TODO + timestamp = \"I thought about this\")\n * - Supports TODO backlog tracking (searchable by function name)\n * - Integrates with user story workflow (reference in comment)\n * - Language-consistent (developers recognize pattern across TS/JS/Python)\n */\n\n/**\n * Parse a function signature and generate a stub\n *\n * don-socratic asks:\n * What languages are we dealing with? (TS, JS, Python)\n * How do we know where to insert the stub?\n * What's the minimal stub that satisfies your definition above?\n *\n * TODO: Implement stub generation\n * TODO: What's the function signature?\n * TODO: What's the return type?\n * TODO: What error do we throw?\n * TODO: What TODO comment do we add?\n */\nexport function generateStub(\n\tfunctionName: string,\n\tparams: string,           // e.g., \"(x: number, y?: string)\" \u2014 keep as-is from signature\n\treturnType: string | null, // e.g., \"string\" or \"Promise<void>\" or null if untyped\n\tlanguage: 'typescript' | 'javascript' | 'python',\n\toptions?: {\n\t\ttimestamp?: string;   // ISO 8601: \"2025-10-23T21:00:00Z\" (optional)\n\t\tuserStory?: string;   // e.g., \"US-142: As a developer...\"  (optional)\n\t}\n): string {\n\t/**\n\t * BUILD THE TODO COMMENT\n\t * \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\t * This is what appears above the function.\n\t * Must include: function name (for TODO backlog search)\n\t * Optional: timestamp (when was this stubbed?), user story (why?)\n\t */\n\tlet todoComment = `TODO: Implement ${functionName}`;\n\n\tif (options?.timestamp) {\n\t\ttodoComment += ` (stubbed ${options.timestamp}`;\n\t\tif (options?.userStory) {\n\t\t\ttodoComment += `, ${options.userStory}`;\n\t\t}\n\t\ttodoComment += ')';\n\t} else if (options?.userStory) {\n\t\ttodoComment += ` (${options.userStory})`;\n\t}\n\n\t/**\n\t * LANGUAGE-SPECIFIC STUB BODY\n\t * \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\t * Two paths: TypeScript/JavaScript vs Python\n\t * Each throws/raises with function name for debugging\n\t */\n\tlet stubBody: string;\n\n\tif (language === 'python') {\n\t\t// Python uses indentation-relative code; caller will add indentation\n\t\t// Format: raise NotImplementedError('function_name')\n\t\tstubBody = `raise NotImplementedError('${functionName}')`;\n\t} else {\n\t\t// TypeScript/JavaScript: throw new Error(...)\n\t\t// Format: throw new Error('Not implemented: functionName')\n\t\tstubBody = `throw new Error('Not implemented: ${functionName}');`;\n\t}\n\n\t/**\n\t * ASSEMBLE THE STUB\n\t * \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\t * Return just the body (not the function signature).\n\t * Caller (insertStub) handles placing this inside the function.\n\t * Include the TODO comment so it appears above.\n\t */\n\treturn `${todoComment}\\n${stubBody}`;\n}\n\n\n\n/**\n * Find @rhizome stub comments in code\n *\n * don-socratic observes:\n * You know regex. So why not start there? Split the code into lines,\n * find the ones with @rhizome stub. You've got line numbers. Easy.\n *\n * Then\u2014and here's where it gets interesting\u2014you need to know what comes next.\n * A function signature. But it looks *different* in each language.\n * Have you thought about what MUST be true about that signature?\n * (Is it always on the very next line? Or could there be whitespace?)\n *\n * For the actual parsing: languages have tools. TypeScript has @babel/parser.\n * Python has ast (built-in!). But you might not need them yet.\n * A regex could get you 80% of the way. What's your tolerance for edge cases?\n * (Nested functions? Async? Arrow functions? Methods in classes?)\n *\n * Start small. Get it working for the simple case.\n * Then ask: what broke? And fix that case.\n * That's how you learn what you actually need.\n *\n * don-socratic asks (again):\n * What does a @rhizome stub comment look like? You answered: //@rhizome, #@rhizome, etc.\n * Good. So write the regex. Then test it on your code. Does it find them?\n *\n * TODO: Write regex to find @rhizome stub comments (you know how)\n * TODO: Extract line number and function signature on next line\n * TODO: What breaks first? Fix that. Then the next thing.\n * TODO: Only then: do I need a proper parser, or is regex enough?\n */\nexport function findStubComments(code: string, language: string): Array<{\n\tline: number;\n\tfunctionName: string;\n\tsignature: string;        // The full function signature from next line(s)\n\tparams: string;           // Just the params: \"(x, y)\" or \"(x: number, y?: string)\"\n\treturnType: string | null; // Return type if present, else null\n}> {\n\tconst results: Array<{\n\t\tline: number;\n\t\tfunctionName: string;\n\t\tsignature: string;\n\t\tparams: string;\n\t\treturnType: string | null;\n\t}> = [];\n\n\t/**\n\t * SPLIT CODE INTO LINES\n\t * \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\t * Preserve line endings for later use (in insertStub).\n\t */\n\tconst lines = code.split('\\n');\n\n\t/**\n\t * REGEX TO FIND @RHIZOME STUB MARKERS\n\t * \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\t * Language-agnostic: works in comments (//, #, /*, etc.)\n\t * Case-insensitive match for robustness\n\t */\n\tconst markerRegex = /@rhizome\\s+stub/i;\n\n\t/**\n\t * REGEX PATTERNS FOR FUNCTION SIGNATURES\n\t * \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\t * TypeScript/JavaScript:\n\t *   - Handles: export, async, function keyword\n\t *   - Captures: name, params, return type\n\t *   - Example: \"export async function getName(x: number): string\"\n\t *\n\t * Python:\n\t *   - Handles: async keyword, def\n\t *   - Captures: name, params, return type\n\t *   - Example: \"async def get_name(x: int) -> str:\"\n\t */\n\tconst tsJsFunctionRegex =\n\t\t/^(?:export\\s+)?(?:const\\s+)?(?:async\\s+)?(?:function\\s+)?(\\w+)\\s*(\\([^)]*\\))(?:\\s*:\\s*([\\w<>\\[\\]|\\s]+))?/;\n\tconst pythonFunctionRegex = /^(?:async\\s+)?def\\s+(\\w+)\\s*(\\([^)]*\\))(?:\\s*->\\s*([\\w\\[\\]]+))?:/;\n\n\t/**\n\t * SCAN FOR MARKERS\n\t * \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\t * For each line with @rhizome stub:\n\t * 1. Record the line number\n\t * 2. Look at next 1-2 lines for function signature\n\t * 3. Extract name, params, return type\n\t * 4. Add to results\n\t */\n\tfor (let i = 0; i < lines.length; i++) {\n\t\tif (markerRegex.test(lines[i])) {\n\t\t\t// Found a @rhizome stub marker\n\t\t\tconst markerLine = i;\n\n\t\t\t// Look at next line(s) for function signature\n\t\t\t// Allow up to 1 blank line between marker and signature\n\t\t\tlet signatureLine = i + 1;\n\t\t\twhile (\n\t\t\t\tsignatureLine < lines.length &&\n\t\t\t\tlines[signatureLine].trim() === ''\n\t\t\t) {\n\t\t\t\tsignatureLine++;\n\t\t\t}\n\n\t\t\tif (signatureLine >= lines.length) {\n\t\t\t\t// No function signature found after marker\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst sig = lines[signatureLine].trim();\n\n\t\t\t// Try to parse the signature\n\t\t\tlet match;\n\t\t\tlet name, params, returnType;\n\n\t\t\tif (\n\t\t\t\tlanguage === 'python'\n\t\t\t) {\n\t\t\t\tmatch = sig.match(pythonFunctionRegex);\n\t\t\t\tif (match) {\n\t\t\t\t\tname = match[1];\n\t\t\t\t\tparams = match[2];\n\t\t\t\t\treturnType = match[3] || null;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// TypeScript / JavaScript\n\t\t\t\tmatch = sig.match(tsJsFunctionRegex);\n\t\t\t\tif (match) {\n\t\t\t\t\tname = match[1];\n\t\t\t\t\tparams = match[2];\n\t\t\t\t\treturnType = match[3]?.trim() || null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (name && params) {\n\t\t\t\tresults.push({\n\t\t\t\t\tline: markerLine,\n\t\t\t\t\tfunctionName: name,\n\t\t\t\t\tsignature: sig,\n\t\t\t\t\tparams: params,\n\t\t\t\t\treturnType: returnType ?? null,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\treturn results;\n}\n\n/**\n * Insert stub into code at specified location\n *\n * don-socratic asks:\n * You've found where to insert. But HOW?\n * Do you replace the entire function signature?\n * Do you keep what was there and add to it?\n * How do you preserve indentation?\n * How do you handle line endings?\n *\n * TODO: Implement stub insertion\n */\nexport function insertStub(\n\tcode: string,\n\tline: number,           // 0-indexed line number where @rhizome stub comment is\n\tstub: string,           // Generated stub code from generateStub()\n\tlanguage: string,\n): string {\n\t/**\n\t * STEP 1: SPLIT CODE AND DETECT LINE ENDINGS\n\t * \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\t * We need to:\n\t * - Track whether the original code uses \\n or \\r\\n\n\t * - Split into lines while preserving structure\n\t * - Insert the stub at the right place\n\t */\n\tconst lineEnding = code.includes('\\r\\n') ? '\\r\\n' : '\\n';\n\tconst lines = code.split('\\n');\n\n\tif (line < 0 || line >= lines.length) {\n\t\tthrow new Error(`Invalid line number: ${line}`);\n\t}\n\n\t/**\n\t * STEP 2: FIND THE SIGNATURE LINE (next non-blank after marker)\n\t * \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\t * The marker is on `line`. The signature is on the next non-blank line.\n\t * (Same logic as in findStubComments)\n\t */\n\tlet signatureLine = line + 1;\n\twhile (signatureLine < lines.length && lines[signatureLine].trim() === '') {\n\t\tsignatureLine++;\n\t}\n\n\tif (signatureLine >= lines.length) {\n\t\tthrow new Error('No function signature found after @rhizome stub marker');\n\t}\n\n\tconst signatureText = lines[signatureLine];\n\tconst indentation = signatureText.match(/^\\s*/)?.[0] || '';\n\n\t/**\n\t * STEP 3: DETECT LANGUAGE AND FIND OPENING BRACE/COLON\n\t * \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\t * TypeScript/JavaScript: look for { (opening brace)\n\t * Python: look for : (colon) at end of def line\n\t *\n\t * If not found on the signature line, assume it's on the next line.\n\t */\n\tlet openingBraceLine = signatureLine;\n\tlet openingBraceIndex = signatureText.indexOf('{');\n\tlet openingColonIndex = signatureText.lastIndexOf(':');\n\n\t// Handle single-line vs multi-line function declarations\n\tif (language === 'python') {\n\t\t// Python: check if this line ends with ':'\n\t\tif (!signatureText.trimEnd().endsWith(':')) {\n\t\t\t// Multi-line signature, look for next line with ':'\n\t\t\topeningBraceLine = signatureLine + 1;\n\t\t\twhile (\n\t\t\t\topeningBraceLine < lines.length &&\n\t\t\t\t!lines[openingBraceLine].trimEnd().endsWith(':')\n\t\t\t) {\n\t\t\t\topeningBraceLine++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// TypeScript/JavaScript: find the {\n\t\tif (openingBraceIndex === -1) {\n\t\t\t// { is on a later line\n\t\t\topeningBraceLine = signatureLine + 1;\n\t\t\twhile (\n\t\t\t\topeningBraceLine < lines.length &&\n\t\t\t\tlines[openingBraceLine].indexOf('{') === -1\n\t\t\t) {\n\t\t\t\topeningBraceLine++;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * STEP 4: PREPARE INDENTED STUB\n\t * \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\t * generateStub() returns:\n\t *   \"TODO: Implement foo\\nthrow new Error(...)\"\n\t * OR\n\t *   \"TODO: Implement foo\\nraise NotImplementedError(...)\"\n\t *\n\t * We need to:\n\t * 1. Split the stub into lines\n\t * 2. Add indentation to each line\n\t * 3. Add one extra level of indentation for the body\n\t */\n\tconst stubLines = stub.split('\\n');\n\tconst bodyIndentation = indentation + '\\t'; // Add one tab for body\n\n\tconst indentedStub = stubLines.map((l) => {\n\t\tif (l === '') return '';\n\t\treturn bodyIndentation + l;\n\t});\n\n\t/**\n\t * STEP 5: INSERT STUB INTO DOCUMENT\n\t * \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\t * Insert after the opening brace/colon\n\t *\n\t * Example before (TypeScript):\n\t *   function getName(x: number): string\n\t *\n\t * Example after:\n\t *   function getName(x: number): string {\n\t *     TODO: Implement getName\n\t *     throw new Error('Not implemented: getName');\n\t *   }\n\t */\n\tif (language === 'python') {\n\t\t// Python: insert after the : line\n\t\tlines.splice(openingBraceLine + 1, 0, ...indentedStub);\n\t} else {\n\t\t// TypeScript/JavaScript: insert after the { line\n\t\t// First, ensure { exists on the opening line\n\t\tif (lines[openingBraceLine].indexOf('{') === -1) {\n\t\t\tlines[openingBraceLine] = lines[openingBraceLine].trimEnd() + ' {';\n\t\t}\n\t\tlines.splice(openingBraceLine + 1, 0, ...indentedStub);\n\n\t\t// Add closing brace if it's not already there\n\t\t// (Simple case: assume we're adding it)\n\t\tlines.splice(openingBraceLine + indentedStub.length + 1, 0, indentation + '}');\n\t}\n\n\t/**\n\t * STEP 6: REASSEMBLE AND RETURN\n\t * \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\t * Join lines with original line ending style\n\t */\n\treturn lines.join(lineEnding);\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,aAAwB;;;AC8CjB,SAAS,aACf,cACA,QACA,YACA,UACA,SAIS;AAQT,MAAI,cAAc,mBAAmB,YAAY;AAEjD,MAAI,SAAS,WAAW;AACvB,mBAAe,aAAa,QAAQ,SAAS;AAC7C,QAAI,SAAS,WAAW;AACvB,qBAAe,KAAK,QAAQ,SAAS;AAAA,IACtC;AACA,mBAAe;AAAA,EAChB,WAAW,SAAS,WAAW;AAC9B,mBAAe,KAAK,QAAQ,SAAS;AAAA,EACtC;AAQA,MAAI;AAEJ,MAAI,aAAa,UAAU;AAG1B,eAAW,8BAA8B,YAAY;AAAA,EACtD,OAAO;AAGN,eAAW,qCAAqC,YAAY;AAAA,EAC7D;AASA,SAAO,GAAG,WAAW;AAAA,EAAK,QAAQ;AACnC;AAkCO,SAAS,iBAAiB,MAAc,UAM5C;AACF,QAAM,UAMD,CAAC;AAON,QAAM,QAAQ,KAAK,MAAM,IAAI;AAQ7B,QAAM,cAAc;AAepB,QAAM,oBACL;AACD,QAAM,sBAAsB;AAW5B,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACtC,QAAI,YAAY,KAAK,MAAM,CAAC,CAAC,GAAG;AAE/B,YAAM,aAAa;AAInB,UAAI,gBAAgB,IAAI;AACxB,aACC,gBAAgB,MAAM,UACtB,MAAM,aAAa,EAAE,KAAK,MAAM,IAC/B;AACD;AAAA,MACD;AAEA,UAAI,iBAAiB,MAAM,QAAQ;AAElC;AAAA,MACD;AAEA,YAAM,MAAM,MAAM,aAAa,EAAE,KAAK;AAGtC,UAAI;AACJ,UAAI,MAAM,QAAQ;AAElB,UACC,aAAa,UACZ;AACD,gBAAQ,IAAI,MAAM,mBAAmB;AACrC,YAAI,OAAO;AACV,iBAAO,MAAM,CAAC;AACd,mBAAS,MAAM,CAAC;AAChB,uBAAa,MAAM,CAAC,KAAK;AAAA,QAC1B;AAAA,MACD,OAAO;AAEN,gBAAQ,IAAI,MAAM,iBAAiB;AACnC,YAAI,OAAO;AACV,iBAAO,MAAM,CAAC;AACd,mBAAS,MAAM,CAAC;AAChB,uBAAa,MAAM,CAAC,GAAG,KAAK,KAAK;AAAA,QAClC;AAAA,MACD;AAEA,UAAI,QAAQ,QAAQ;AACnB,gBAAQ,KAAK;AAAA,UACZ,MAAM;AAAA,UACN,cAAc;AAAA,UACd,WAAW;AAAA,UACX;AAAA,UACA,YAAY,cAAc;AAAA,QAC3B,CAAC;AAAA,MACF;AAAA,IACD;AAAA,EACD;AAEA,SAAO;AACR;AAcO,SAAS,WACf,MACA,MACA,MACA,UACS;AAST,QAAM,aAAa,KAAK,SAAS,MAAM,IAAI,SAAS;AACpD,QAAM,QAAQ,KAAK,MAAM,IAAI;AAE7B,MAAI,OAAO,KAAK,QAAQ,MAAM,QAAQ;AACrC,UAAM,IAAI,MAAM,wBAAwB,IAAI,EAAE;AAAA,EAC/C;AAQA,MAAI,gBAAgB,OAAO;AAC3B,SAAO,gBAAgB,MAAM,UAAU,MAAM,aAAa,EAAE,KAAK,MAAM,IAAI;AAC1E;AAAA,EACD;AAEA,MAAI,iBAAiB,MAAM,QAAQ;AAClC,UAAM,IAAI,MAAM,wDAAwD;AAAA,EACzE;AAEA,QAAM,gBAAgB,MAAM,aAAa;AACzC,QAAM,cAAc,cAAc,MAAM,MAAM,IAAI,CAAC,KAAK;AAUxD,MAAI,mBAAmB;AACvB,MAAI,oBAAoB,cAAc,QAAQ,GAAG;AACjD,MAAI,oBAAoB,cAAc,YAAY,GAAG;AAGrD,MAAI,aAAa,UAAU;AAE1B,QAAI,CAAC,cAAc,QAAQ,EAAE,SAAS,GAAG,GAAG;AAE3C,yBAAmB,gBAAgB;AACnC,aACC,mBAAmB,MAAM,UACzB,CAAC,MAAM,gBAAgB,EAAE,QAAQ,EAAE,SAAS,GAAG,GAC9C;AACD;AAAA,MACD;AAAA,IACD;AAAA,EACD,OAAO;AAEN,QAAI,sBAAsB,IAAI;AAE7B,yBAAmB,gBAAgB;AACnC,aACC,mBAAmB,MAAM,UACzB,MAAM,gBAAgB,EAAE,QAAQ,GAAG,MAAM,IACxC;AACD;AAAA,MACD;AAAA,IACD;AAAA,EACD;AAeA,QAAM,YAAY,KAAK,MAAM,IAAI;AACjC,QAAM,kBAAkB,cAAc;AAEtC,QAAM,eAAe,UAAU,IAAI,CAAC,MAAM;AACzC,QAAI,MAAM;AAAI,aAAO;AACrB,WAAO,kBAAkB;AAAA,EAC1B,CAAC;AAgBD,MAAI,aAAa,UAAU;AAE1B,UAAM,OAAO,mBAAmB,GAAG,GAAG,GAAG,YAAY;AAAA,EACtD,OAAO;AAGN,QAAI,MAAM,gBAAgB,EAAE,QAAQ,GAAG,MAAM,IAAI;AAChD,YAAM,gBAAgB,IAAI,MAAM,gBAAgB,EAAE,QAAQ,IAAI;AAAA,IAC/D;AACA,UAAM,OAAO,mBAAmB,GAAG,GAAG,GAAG,YAAY;AAIrD,UAAM,OAAO,mBAAmB,aAAa,SAAS,GAAG,GAAG,cAAc,GAAG;AAAA,EAC9E;AAOA,SAAO,MAAM,KAAK,UAAU;AAC7B;;;ADnWO,SAAS,SAAS,SAAkC;AAC1D,UAAQ,IAAI,0BAA0B;AAkBtC,MAAI,wBAA+B,gBAAS,gBAAgB,8BAA8B,YAAY;AACrG,UAAM,SAAgB,cAAO;AAC7B,QAAI,CAAC,QAAQ;AACZ,MAAO,cAAO,iBAAiB,kBAAkB;AACjD;AAAA,IACD;AAEA,UAAM,YAAY,OAAO;AACzB,UAAM,eAAe,OAAO,SAAS,QAAQ,SAAS;AAEtD,QAAI,CAAC,cAAc;AAClB,MAAO,cAAO,iBAAiB,gCAAgC;AAC/D;AAAA,IACD;AAGA,UAAa,cAAO,uBAAuB,wBAAwB;AAGnE,UAAM,gBAAuB,cAAO,oBAAoB,gBAAgB;AACxE,kBAAc,KAAK,IAAI;AAGvB,kBAAc,WAAW,IAAI,OAAO,EAAE,CAAC;AACvC,kBAAc,WAAW,cAAc;AACvC,kBAAc,WAAW,IAAI,OAAO,EAAE,CAAC;AACvC,kBAAc,WAAW,gBAAgB;AACzC,kBAAc,WAAW,EAAE;AAC3B,kBAAc,WAAW,YAAY;AACrC,kBAAc,WAAW,EAAE;AAC3B,kBAAc,WAAW,sCAAsC;AAC/D,kBAAc,WAAW,EAAE;AAmB3B,QAAI;AACH,YAAM,EAAE,SAAS,IAAI,QAAQ,eAAe;AAC5C,YAAM,WAAW,SAAS,wCAAwC;AAAA,QACjE,OAAO;AAAA,QACP,UAAU;AAAA,QACV,SAAS;AAAA;AAAA,MACV,CAAC;AACD,oBAAc,WAAW,EAAE;AAC3B,oBAAc,WAAW,6BAA6B;AACtD,oBAAc,WAAW,EAAE;AAC3B,oBAAc,WAAW,QAAQ;AAAA,IAClC,SAAS,OAAY;AACpB,oBAAc,WAAW,EAAE;AAC3B,oBAAc,WAAW,4BAA4B;AACrD,oBAAc,WAAY,MAAgB,OAAO;AACjD,oBAAc,WAAW,EAAE;AAC3B,oBAAc,WAAW,kDAAkD;AAAA,IAC5E;AAAA,EACD,CAAC;AAED,UAAQ,cAAc,KAAK,qBAAqB;AA6BhD,MAAI,iBAAwB,gBAAS,gBAAgB,uBAAuB,YAAY;AACvF,UAAM,SAAgB,cAAO;AAC7B,QAAI,CAAC,QAAQ;AACZ,MAAO,cAAO,iBAAiB,kBAAkB;AACjD;AAAA,IACD;AAEA,UAAM,WAAW,OAAO;AACxB,UAAM,OAAO,SAAS,QAAQ;AAG9B,UAAM,MAAM,SAAS;AACrB,UAAM,WAAW,QAAQ,gBAAgB,QAAQ,eAAe,eAAe,QAAQ,WAAW,WAAW;AAE7G,QAAI,CAAC,UAAU;AACd,MAAO,cAAO,iBAAiB,yBAAyB,GAAG,0CAA0C;AACrG;AAAA,IACD;AAGA,UAAM,QAAQ,iBAAiB,MAAM,QAAQ;AAE7C,QAAI,MAAM,WAAW,GAAG;AACvB,MAAO,cAAO,mBAAmB,8CAA8C;AAC/E;AAAA,IACD;AAGA,QAAI,aAAa,MAAM,CAAC;AACxB,QAAI,MAAM,SAAS,GAAG;AACrB,YAAM,SAAS,MAAa,cAAO;AAAA,QAClC,MAAM,IAAI,CAAC,MAAM,QAAQ,EAAE,IAAI,KAAK,EAAE,YAAY,EAAE;AAAA,QACpD,EAAE,aAAa,0BAA0B;AAAA,MAC1C;AACA,UAAI,CAAC;AAAQ;AACb,YAAM,QAAQ,MAAM,IAAI,CAAC,MAAM,QAAQ,EAAE,IAAI,KAAK,EAAE,YAAY,EAAE,EAAE,QAAQ,MAAM;AAClF,mBAAa,MAAM,KAAK;AAAA,IACzB;AAGA,UAAM,OAAO,aAAa,WAAW,cAAc,WAAW,QAAQ,WAAW,YAAY,QAAe;AAG5G,UAAM,eAAe,WAAW,MAAM,WAAW,MAAM,MAAM,QAAQ;AAGrE,UAAM,YAAY,IAAW,aAAM,SAAS,WAAW,CAAC,GAAG,SAAS,WAAW,KAAK,MAAM,CAAC;AAC3F,UAAM,OAAO,IAAW,gBAAS,WAAW,YAAY;AAGxD,UAAM,gBAAgB,IAAW,qBAAc;AAC/C,kBAAc,IAAI,SAAS,KAAK,CAAC,IAAI,CAAC;AACtC,UAAa,iBAAU,UAAU,aAAa;AAE9C,IAAO,cAAO,uBAAuB,oBAAoB,WAAW,YAAY,EAAE;AAAA,EACnF,CAAC;AAED,UAAQ,cAAc,KAAK,cAAc;AAC1C;AAEO,SAAS,aAAa;AAAC;",
  "names": []
}
